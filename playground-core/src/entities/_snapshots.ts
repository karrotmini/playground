// Generated by atdts from type definitions in '_snapshots.atd'.
//
// Type-safe translations from/to JSON
//
// For each type 'Foo', there is a pair of functions:
// - 'writeFoo': convert a 'Foo' value into a JSON-compatible value.
// - 'readFoo': convert a JSON-compatible value into a TypeScript value
//   of type 'Foo'.


export type Timestamp = Int

export type AppManifest = {
  app_id: string;
  name: string;
}

export type AppSnapshotV1 = {
  name: string;
  created_at: Timestamp;
  tenant_id: string;
  owner_id: (string | null);
  custom_host_id: string;
  bundles: BundleRef[];
  deployments: [string, DeploymentRef][];
}

export type BundleTemplateRef = {
  id: string;
}

export type BundleUploadRef = {
  id: string;
}

export type BundleRef =
| { kind: 'Template'; value: BundleTemplateRef }
| { kind: 'Upload'; value: BundleUploadRef }

export type DeploymentRef = {
  name: string;
  bundle: BundleRef;
  custom_host_id: string;
  deployed_at: Timestamp;
}

export type BundleUploadSnapshotV1 = {
  app_id: string;
  tag: string;
  uploader_id: string;
  created_at: Timestamp;
  manifest: (AppManifest | null);
}

export type UserProfileSnapshotV1 = {
  app_ids: string[];
  name: (string | null);
  profile_image_url: (string | null);
}

export function writeTimestamp(x: Timestamp, context: any = x): any {
  return _atd_write_int(x, context);
}

export function readTimestamp(x: any, context: any = x): Timestamp {
  return _atd_read_int(x, context);
}

export function writeAppManifest(x: AppManifest, context: any = x): any {
  return {
    'app_id': _atd_write_required_field('AppManifest', 'app_id', _atd_write_string, x.app_id, x),
    'name': _atd_write_required_field('AppManifest', 'name', _atd_write_string, x.name, x),
  };
}

export function readAppManifest(x: any, context: any = x): AppManifest {
  return {
    app_id: _atd_read_required_field('AppManifest', 'app_id', _atd_read_string, x['app_id'], x),
    name: _atd_read_required_field('AppManifest', 'name', _atd_read_string, x['name'], x),
  };
}

export function writeAppSnapshotV1(x: AppSnapshotV1, context: any = x): any {
  return {
    'name': _atd_write_required_field('AppSnapshotV1', 'name', _atd_write_string, x.name, x),
    'created_at': _atd_write_required_field('AppSnapshotV1', 'created_at', writeTimestamp, x.created_at, x),
    'tenant_id': _atd_write_required_field('AppSnapshotV1', 'tenant_id', _atd_write_string, x.tenant_id, x),
    'owner_id': _atd_write_required_field('AppSnapshotV1', 'owner_id', _atd_write_nullable(_atd_write_string), x.owner_id, x),
    'custom_host_id': _atd_write_required_field('AppSnapshotV1', 'custom_host_id', _atd_write_string, x.custom_host_id, x),
    'bundles': _atd_write_required_field('AppSnapshotV1', 'bundles', _atd_write_array(writeBundleRef), x.bundles, x),
    'deployments': _atd_write_required_field('AppSnapshotV1', 'deployments', _atd_write_array(((x, context) => [_atd_write_string(x[0], x), writeDeploymentRef(x[1], x)])), x.deployments, x),
  };
}

export function readAppSnapshotV1(x: any, context: any = x): AppSnapshotV1 {
  return {
    name: _atd_read_required_field('AppSnapshotV1', 'name', _atd_read_string, x['name'], x),
    created_at: _atd_read_required_field('AppSnapshotV1', 'created_at', readTimestamp, x['created_at'], x),
    tenant_id: _atd_read_required_field('AppSnapshotV1', 'tenant_id', _atd_read_string, x['tenant_id'], x),
    owner_id: _atd_read_required_field('AppSnapshotV1', 'owner_id', _atd_read_nullable(_atd_read_string), x['owner_id'], x),
    custom_host_id: _atd_read_required_field('AppSnapshotV1', 'custom_host_id', _atd_read_string, x['custom_host_id'], x),
    bundles: _atd_read_required_field('AppSnapshotV1', 'bundles', _atd_read_array(readBundleRef), x['bundles'], x),
    deployments: _atd_read_required_field('AppSnapshotV1', 'deployments', _atd_read_array(((x, context): [string, DeploymentRef] => { _atd_check_json_tuple(2, x, context); return [_atd_read_string(x[0], x), readDeploymentRef(x[1], x)] })), x['deployments'], x),
  };
}

export function writeBundleTemplateRef(x: BundleTemplateRef, context: any = x): any {
  return {
    'id': _atd_write_required_field('BundleTemplateRef', 'id', _atd_write_string, x.id, x),
  };
}

export function readBundleTemplateRef(x: any, context: any = x): BundleTemplateRef {
  return {
    id: _atd_read_required_field('BundleTemplateRef', 'id', _atd_read_string, x['id'], x),
  };
}

export function writeBundleUploadRef(x: BundleUploadRef, context: any = x): any {
  return {
    'id': _atd_write_required_field('BundleUploadRef', 'id', _atd_write_string, x.id, x),
  };
}

export function readBundleUploadRef(x: any, context: any = x): BundleUploadRef {
  return {
    id: _atd_read_required_field('BundleUploadRef', 'id', _atd_read_string, x['id'], x),
  };
}

export function writeBundleRef(x: BundleRef, context: any = x): any {
  switch (x.kind) {
    case 'Template':
      return ['Template', writeBundleTemplateRef(x.value, x)]
    case 'Upload':
      return ['Upload', writeBundleUploadRef(x.value, x)]
  }
}

export function readBundleRef(x: any, context: any = x): BundleRef {
  _atd_check_json_tuple(2, x, context)
  switch (x[0]) {
    case 'Template':
      return { kind: 'Template', value: readBundleTemplateRef(x[1], x) }
    case 'Upload':
      return { kind: 'Upload', value: readBundleUploadRef(x[1], x) }
    default:
      _atd_bad_json('BundleRef', x, context)
      throw new Error('impossible')
  }
}

export function writeDeploymentRef(x: DeploymentRef, context: any = x): any {
  return {
    'name': _atd_write_required_field('DeploymentRef', 'name', _atd_write_string, x.name, x),
    'bundle': _atd_write_required_field('DeploymentRef', 'bundle', writeBundleRef, x.bundle, x),
    'custom_host_id': _atd_write_required_field('DeploymentRef', 'custom_host_id', _atd_write_string, x.custom_host_id, x),
    'deployed_at': _atd_write_required_field('DeploymentRef', 'deployed_at', writeTimestamp, x.deployed_at, x),
  };
}

export function readDeploymentRef(x: any, context: any = x): DeploymentRef {
  return {
    name: _atd_read_required_field('DeploymentRef', 'name', _atd_read_string, x['name'], x),
    bundle: _atd_read_required_field('DeploymentRef', 'bundle', readBundleRef, x['bundle'], x),
    custom_host_id: _atd_read_required_field('DeploymentRef', 'custom_host_id', _atd_read_string, x['custom_host_id'], x),
    deployed_at: _atd_read_required_field('DeploymentRef', 'deployed_at', readTimestamp, x['deployed_at'], x),
  };
}

export function writeBundleUploadSnapshotV1(x: BundleUploadSnapshotV1, context: any = x): any {
  return {
    'app_id': _atd_write_required_field('BundleUploadSnapshotV1', 'app_id', _atd_write_string, x.app_id, x),
    'tag': _atd_write_required_field('BundleUploadSnapshotV1', 'tag', _atd_write_string, x.tag, x),
    'uploader_id': _atd_write_required_field('BundleUploadSnapshotV1', 'uploader_id', _atd_write_string, x.uploader_id, x),
    'created_at': _atd_write_required_field('BundleUploadSnapshotV1', 'created_at', writeTimestamp, x.created_at, x),
    'manifest': _atd_write_required_field('BundleUploadSnapshotV1', 'manifest', _atd_write_nullable(writeAppManifest), x.manifest, x),
  };
}

export function readBundleUploadSnapshotV1(x: any, context: any = x): BundleUploadSnapshotV1 {
  return {
    app_id: _atd_read_required_field('BundleUploadSnapshotV1', 'app_id', _atd_read_string, x['app_id'], x),
    tag: _atd_read_required_field('BundleUploadSnapshotV1', 'tag', _atd_read_string, x['tag'], x),
    uploader_id: _atd_read_required_field('BundleUploadSnapshotV1', 'uploader_id', _atd_read_string, x['uploader_id'], x),
    created_at: _atd_read_required_field('BundleUploadSnapshotV1', 'created_at', readTimestamp, x['created_at'], x),
    manifest: _atd_read_required_field('BundleUploadSnapshotV1', 'manifest', _atd_read_nullable(readAppManifest), x['manifest'], x),
  };
}

export function writeUserProfileSnapshotV1(x: UserProfileSnapshotV1, context: any = x): any {
  return {
    'app_ids': _atd_write_required_field('UserProfileSnapshotV1', 'app_ids', _atd_write_array(_atd_write_string), x.app_ids, x),
    'name': _atd_write_required_field('UserProfileSnapshotV1', 'name', _atd_write_nullable(_atd_write_string), x.name, x),
    'profile_image_url': _atd_write_required_field('UserProfileSnapshotV1', 'profile_image_url', _atd_write_nullable(_atd_write_string), x.profile_image_url, x),
  };
}

export function readUserProfileSnapshotV1(x: any, context: any = x): UserProfileSnapshotV1 {
  return {
    app_ids: _atd_read_required_field('UserProfileSnapshotV1', 'app_ids', _atd_read_array(_atd_read_string), x['app_ids'], x),
    name: _atd_read_required_field('UserProfileSnapshotV1', 'name', _atd_read_nullable(_atd_read_string), x['name'], x),
    profile_image_url: _atd_read_required_field('UserProfileSnapshotV1', 'profile_image_url', _atd_read_nullable(_atd_read_string), x['profile_image_url'], x),
  };
}


/////////////////////////////////////////////////////////////////////
// Runtime library
/////////////////////////////////////////////////////////////////////

export type Int = number

export type Option<T> = null | { value: T }

function _atd_missing_json_field(type_name: string, json_field_name: string) {
    throw new Error(`missing field '${json_field_name}'` +
                    ` in JSON object of type '${type_name}'`)
}

function _atd_missing_ts_field(type_name: string, ts_field_name: string) {
    throw new Error(`missing field '${ts_field_name}'` +
                    ` in TypeScript object of type '${type_name}'`)
}

function _atd_bad_json(expected_type: string, json_value: any, context: any) {
  let value_str = JSON.stringify(json_value)
  if (value_str.length > 200)
    value_str = value_str.substring(0, 200) + '…';

  throw new Error(`incompatible JSON value where` +
                  ` type '${expected_type}' was expected: '${value_str}'.` +
                  ` Occurs in '${JSON.stringify(context)}'.`)
}

function _atd_bad_ts(expected_type: string, ts_value: any, context: any) {
  let value_str = JSON.stringify(ts_value)
  if (value_str.length > 200)
    value_str = value_str.substring(0, 200) + '…';

  throw new Error(`incompatible TypeScript value where` +
                  ` type '${expected_type}' was expected: '${value_str}'.` +
                  ` Occurs in '${JSON.stringify(context)}'.`)
}

function _atd_check_json_tuple(len: Int, x: any, context: any) {
  if (! Array.isArray(x) || x.length !== len)
    _atd_bad_json('tuple of length ' + len, x, context);
}

function _atd_read_unit(x: any, context: any): null {
  if (x === null)
    return null
  else {
    _atd_bad_json('null', x, context)
    throw new Error('impossible')
  }
}

function _atd_read_bool(x: any, context: any): boolean {
  if (typeof x === 'boolean')
    return x
  else {
    _atd_bad_json('boolean', x, context)
    throw new Error('impossible')
  }
}

function _atd_read_int(x: any, context: any): Int {
  if (Number.isInteger(x))
    return x
  else {
    _atd_bad_json('integer', x, context)
    throw new Error('impossible')
  }
}

function _atd_read_float(x: any, context: any): number {
  if (isFinite(x))
    return x
  else {
    _atd_bad_json('number', x, context)
    throw new Error('impossible')
  }
}

function _atd_read_string(x: any, context: any): string {
  if (typeof x === 'string')
    return x
  else {
    _atd_bad_json('string', x, context)
    throw new Error('impossible')
  }
}

function _atd_read_required_field<T>(type_name: string,
                                     field_name: string,
                                     read_elt: (x: any, context: any) => T,
                                     x: any,
                                     context: any): T {
  if (x === undefined) {
    _atd_missing_json_field(type_name, field_name)
    throw new Error('impossible')
  }
  else
    return read_elt(x, context)
}

function _atd_read_optional_field<T>(read_elt: (x: any, context: any) => T,
                                     x: any,
                                     context: any): T {
  if (x === undefined || x === null)
    return x
  else
    return read_elt(x, context)
}

function _atd_read_field_with_default<T>(read_elt: (x: any, context: any) => T,
                                         default_: T,
                                         x: any,
                                         context: any): T {
  if (x === undefined || x === null)
    return default_
  else
    return read_elt(x, context)
}

function _atd_read_option<T>(read_elt: (x: any, context: any) => T):
  (x: any, context: any) => Option<T> {
  function read_option(x: any, context: any): Option<T> {
    if (x === 'None')
      return null
    else {
      _atd_check_json_tuple(2, x, context);
      switch (x[0]) {
        case 'Some':
          return { value: read_elt(x[1], context) }
        default:
          _atd_bad_json('option', x, context)
          throw new Error('impossible')
      }
    }
  }
  return read_option
}

function _atd_read_nullable<T>(read_elt: (x: any, context: any) => T):
  (x: any, context: any) => T | null {
  function read_nullable(x: any, context: any): T | null {
    if (x === null)
      return null
    else
      return read_elt(x, context)
  }
  return read_nullable
}

function _atd_read_array<T>(read_elt: (x: any, context: any) => T):
  (elts: any, context: any) => T[] {
  function read_array(elts: any, context: any): T[] {
    if (Array.isArray(elts))
      return elts.map((x) => read_elt(x, elts))
    else {
      _atd_bad_json('array', elts, context)
      throw new Error('impossible')
    }
  }
  return read_array
}

function _atd_read_assoc_array_into_map<K, V>(
    read_key: (key: any, context: any) => K,
    read_value: (value: any, context: any) => V
  ): (x: any, context: any) => Map<K, V> {
  function read_assoc(elts: any, context: any): Map<K, V> {
    if (Array.isArray(elts)) {
      const res = new Map<K, V>([])
      for (const x of elts) {
        if (Array.isArray(x) && x.length === 2)
          res.set(read_key(x[0], x), read_value(x[1], x))
        else {
          _atd_bad_json('pair', x, elts)
          throw new Error('impossible')
        }
      }
      return res
    }
    else {
      _atd_bad_json('array', elts, context)
      throw new Error('impossible')
    }
  }
  return read_assoc
}

function _atd_read_assoc_object_into_map<T>(
    read_value: (value: any, context: any) => T
  ): (x: any, context: any) => Map<string, T> {
  function read_assoc(elts: any, context: any): Map<string, T> {
    if (typeof elts === 'object') {
      const res = new Map<string, T>([])
      for (const [key, value] of Object.entries(elts))
        res.set(key, read_value(value, elts))
      return res
    }
    else {
      _atd_bad_json('object', elts, context)
      throw new Error('impossible')
    }
  }
  return read_assoc
}

function _atd_read_assoc_object_into_array<T>(
    read_value: (value: any, context: any) => T
  ): (x: any, context: any) => [string, T][] {
  function read_assoc(elts: any, context: any): [string, T][] {
    if (typeof elts === 'object') {
      const res: [string, T][] = []
      for (const [key, value] of Object.entries(elts))
        res.push([key, read_value(value, elts)])
      return res
    }
    else {
      _atd_bad_json('object', elts, context)
      throw new Error('impossible')
    }
  }
  return read_assoc
}

function _atd_write_unit(x: any, context: any) {
  if (x === null)
    return x
  else {
    _atd_bad_ts('null', x, context)
    throw new Error('impossible')
  }
}

function _atd_write_bool(x: any, context: any): boolean {
  if (typeof x === 'boolean')
    return x
  else {
    _atd_bad_ts('boolean', x, context)
    throw new Error('impossible')
  }
}

function _atd_write_int(x: any, context: any): Int {
  if (Number.isInteger(x))
    return x
  else {
    _atd_bad_ts('integer', x, context)
    throw new Error('impossible')
  }
}

function _atd_write_float(x: any, context: any): number {
  if (isFinite(x))
    return x
  else {
    _atd_bad_ts('number', x, context)
    throw new Error('impossible')
  }
}

function _atd_write_string(x: any, context: any): string {
  if (typeof x === 'string')
    return x
  else {
    _atd_bad_ts('string', x, context)
    throw new Error('impossible')
  }
}

function _atd_write_option<T>(write_elt: (x: T, context: any) => any):
   (elts: Option<T>, context: any) => any {
  function write_option(x: Option<T>, context: any): any {
    if (x === null)
      return 'None'
    else
      return ['Some', write_elt(x.value, context)]
  }
  return write_option
}

function _atd_write_nullable<T>(write_elt: (x: T, context: any) => any):
  (x: T | null, context: any) => any {
  function write_option(x: T | null, context: any): any {
    if (x === null)
      return null
    else
      return write_elt(x, context)
  }
  return write_option
}

function _atd_write_array<T>(write_elt: (elt: T, context: any) => any):
  (elts: T[], context: any) => any {
  return ((elts: T[], context: any): any =>
    elts.map((x) => write_elt(x, elts))
  )
}

function _atd_write_assoc_map_to_array<K, V>(
    write_key: (key: K, context: any) => any,
    write_value: (value: V, context: any) => any
  ): (elts: Map<K, V>, context: any) => any {
  function write_assoc(elts: Map<K, V>, context: any): any {
    const res: any = []
    elts.forEach((value: V, key: K) =>
      res.push([write_key(key, elts), write_value(value, elts)])
    )
    return res
  }
  return write_assoc
}

function _atd_write_assoc_map_to_object<T>(
    write_value: (value: T, context: any) => any
  ): (elts: Map<string, T>, context: any) => any {
  function write_assoc(elts: Map<string, T>, context: any): any {
    const res: any = {}
    elts.forEach((value: T, key: string) =>
      res[key] = write_value(value, elts)
    )
    return res
  }
  return write_assoc
}

function _atd_write_assoc_array_to_object<T>(
    write_value: (value: T, context: any) => any
  ): (elts: [string, T][], context: any) => any {
  function write_assoc(elts: [string, T][], context: any): any {
    const res: any = {}
    for (const [key, value] of elts)
      res[key] = write_value(value, elts)
    return res
  }
  return write_assoc
}

function _atd_write_required_field<T>(type_name: string,
                                      field_name: string,
                                      write_elt: (x: T, context: any) => any,
                                      x: T,
                                      context: any): any {
  if (x === undefined) {
    _atd_missing_ts_field(type_name, field_name)
    throw new Error('impossible')
  }
  else
    return write_elt(x, context)
}

function _atd_write_optional_field<T>(write_elt: (x: T, context: any) => any,
                                      x: T,
                                      context: any): any {
  if (x === undefined || x === null)
    return x
  else
    return write_elt(x, context)
}

function _atd_write_field_with_default<T>(
  write_elt: (x: T, context: any) => any,
  default_: T,
  x: T,
  context: any
): T {
  const value = (x === undefined || x === null) ? default_ : x
  return write_elt(value, context)
}

